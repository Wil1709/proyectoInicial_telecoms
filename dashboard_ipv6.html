<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Sensor Ultrasónico</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(1200px 800px at 20% 10%, #0f1b3d 0%, #0b132b 40%, #050914 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        /* Lienzo del campo estelar (fondo) */
        #starfield {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 0;           /* Detrás del contenido */
            pointer-events: none; /* No bloquea interacción */
            display: block;
            background: transparent;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1; /* Encima del fondo estrellado */
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-title {
            font-size: 0.9rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
        }

        .stat-unit {
            font-size: 1rem;
            color: #666;
            margin-left: 5px;
        }

                 .charts-container {
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: 20px;
             margin-bottom: 30px;
         }

         .chart-card {
             background: rgba(255, 255, 255, 0.95);
             border-radius: 15px;
             padding: 25px;
             box-shadow: 0 8px 32px rgba(0,0,0,0.1);
             backdrop-filter: blur(10px);
             border: 1px solid rgba(255,255,255,0.2);
             height: 300px;
         }

        .chart-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

                 .main-chart {
             background: rgba(255, 255, 255, 0.95);
             border-radius: 15px;
             padding: 25px;
             box-shadow: 0 8px 32px rgba(0,0,0,0.1);
             backdrop-filter: blur(10px);
             border: 1px solid rgba(255,255,255,0.2);
             margin-bottom: 20px;
             height: 400px;
         }

        .main-chart-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 2s infinite;
        }

        .status-connected {
            background-color: #4CAF50;
        }

        .status-disconnected {
            background-color: #f44336;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .connection-status {
            text-align: center;
            margin-bottom: 20px;
            color: white;
            font-size: 1.1rem;
        }

        .ipv6-info {
            margin-top: 8px;
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .ipv6-info span {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }
    </style>
</head>
<body>
    <!-- Fondo: cielo estrellado -->
    <canvas id="starfield"></canvas>
    <div class="container">
        <div class="header">
            <h1>📊 Dashboard Sensor Ultrasónico</h1>
            <p>Monitoreo en tiempo real de distancias</p>
        </div>

        <div class="connection-status">
            <span class="status-indicator status-disconnected" id="status-indicator"></span>
            <span id="connection-text">Desconectado</span>
            <div class="ipv6-info">
                <span id="ipv6-address">Cargando IPv6...</span>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-title">Distancia Actual</div>
                <div class="stat-value" id="current-distance">--</div>
                <span class="stat-unit">cm</span>
            </div>
            <div class="stat-card">
                <div class="stat-title">Distancia Mínima</div>
                <div class="stat-value" id="min-distance">--</div>
                <span class="stat-unit">cm</span>
            </div>
            <div class="stat-card">
                <div class="stat-title">Distancia Máxima</div>
                <div class="stat-value" id="max-distance">--</div>
                <span class="stat-unit">cm</span>
            </div>
            <div class="stat-card">
                <div class="stat-title">Promedio</div>
                <div class="stat-value" id="avg-distance">--</div>
                <span class="stat-unit">cm</span>
            </div>
            <div class="stat-card">
                <div class="stat-title">Total Lecturas</div>
                <div class="stat-value" id="total-readings">0</div>
                <span class="stat-unit">datos</span>
            </div>
            <div class="stat-card">
                <div class="stat-title">Última Actualización</div>
                <div class="stat-value" id="last-update">--</div>
                <span class="stat-unit">hace 0s</span>
            </div>
        </div>

        <div class="charts-container">
            <div class="chart-card">
                <div class="chart-title">Distribución de Distancias</div>
                <canvas id="histogramChart"></canvas>
            </div>
            <div class="chart-card">
                <div class="chart-title">Tendencia de los Últimos 20 Datos</div>
                <canvas id="trendChart"></canvas>
            </div>
        </div>

        <div class="main-chart">
            <div class="main-chart-title">📈 Gráfica en Tiempo Real</div>
            <canvas id="realtimeChart"></canvas>
        </div>
    </div>

    <script>
        // Animación simple de cielo estrellado
        (function() {
            const canvas = document.getElementById('starfield');
            const ctx = canvas.getContext('2d');
            let stars = [];
            let width, height, dpr;

            function resize() {
                dpr = Math.max(window.devicePixelRatio || 1, 1);
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = Math.floor(width * dpr);
                canvas.height = Math.floor(height * dpr);
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                initStars();
            }

            function initStars() {
                const starCount = Math.min(300, Math.floor((width * height) / 8000));
                stars = new Array(starCount).fill(0).map(() => ({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    r: Math.random() * 1.2 + 0.3,
                    twinkle: Math.random() * 0.8 + 0.2,
                    phase: Math.random() * Math.PI * 2,
                    speedY: Math.random() * 0.06 + 0.02
                }));
            }

            function draw() {
                ctx.clearRect(0, 0, width, height);

                // Sutil nebulosa
                const grad = ctx.createRadialGradient(width*0.7, height*0.2, 0, width*0.7, height*0.2, Math.max(width, height)*0.8);
                grad.addColorStop(0, 'rgba(88,130,236,0.09)');
                grad.addColorStop(1, 'rgba(5,9,20,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);

                // Estrellas
                for (const s of stars) {
                    s.y += s.speedY;
                    if (s.y > height + 2) { s.y = -2; s.x = Math.random() * width; }
                    s.phase += 0.02;
                    const alpha = 0.6 + Math.sin(s.phase) * s.twinkle * 0.5;
                    ctx.globalAlpha = Math.max(0.1, Math.min(1, alpha));
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                requestAnimationFrame(draw);
            }

            window.addEventListener('resize', resize);
            resize();
            requestAnimationFrame(draw);
        })();

        // Variables globales
        let ws;
        let allData = [];
        let realtimeChart, histogramChart, trendChart;
        let isConnected = false;
        let hasPreloaded = false;
        const seenTimestamps = new Set();

        // Elementos del DOM
        const statusIndicator = document.getElementById('status-indicator');
        const connectionText = document.getElementById('connection-text');
        const ipv6Address = document.getElementById('ipv6-address');
        const currentDistance = document.getElementById('current-distance');
        const minDistance = document.getElementById('min-distance');
        const maxDistance = document.getElementById('max-distance');
        const avgDistance = document.getElementById('avg-distance');
        const totalReadings = document.getElementById('total-readings');
        const lastUpdate = document.getElementById('last-update');

        // Configuración de gráficas
        const chartColors = {
            primary: 'rgba(54, 162, 235, 0.8)',
            secondary: 'rgba(255, 99, 132, 0.8)',
            background: 'rgba(255, 255, 255, 0.1)',
            border: 'rgba(54, 162, 235, 1)'
        };

        // Inicializar gráfica de tiempo real
        function initRealtimeChart() {
            const ctx = document.getElementById('realtimeChart').getContext('2d');
            realtimeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Distancia (cm)',
                        data: [],
                        borderColor: chartColors.border,
                        backgroundColor: chartColors.primary,
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    height: 350,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#333',
                                font: {
                                    size: 14
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        }
                    },
                    animation: {
                        duration: 750,
                        easing: 'easeInOutQuart'
                    }
                }
            });
        }

        // Inicializar gráfica de histograma
        function initHistogramChart() {
            const ctx = document.getElementById('histogramChart').getContext('2d');
            histogramChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Frecuencia',
                        data: [],
                        backgroundColor: chartColors.secondary,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    height: 250,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        }
                    }
                }
            });
        }

        // Inicializar gráfica de tendencia
        function initTrendChart() {
            const ctx = document.getElementById('trendChart').getContext('2d');
            trendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Tendencia',
                        data: [],
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    height: 250,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#333'
                            }
                        }
                    }
                }
            });
        }

        // Añadir lectura de forma segura (evita duplicados por timestamp)
        function addReading(reading) {
            if (!reading || !reading.timestamp) return false;
            if (seenTimestamps.has(reading.timestamp)) return false;
            seenTimestamps.add(reading.timestamp);
            allData.push(reading);
            return true;
        }

        // Actualizar estadísticas
        function updateStats() {
            if (allData.length === 0) return;

            const distances = allData.map(d => d.distance_cm);
            const current = distances[distances.length - 1];
            const min = Math.min(...distances);
            const max = Math.max(...distances);
            const avg = (distances.reduce((a, b) => a + b, 0) / distances.length).toFixed(2);

            currentDistance.textContent = current.toFixed(2);
            minDistance.textContent = min.toFixed(2);
            maxDistance.textContent = max.toFixed(2);
            avgDistance.textContent = avg;
            totalReadings.textContent = seenTimestamps.size;
        }

        // Actualizar gráfica de tiempo real
        function updateRealtimeChart() {
            if (allData.length === 0) return;

            // Mantener solo los últimos 50 puntos para mejor rendimiento
            const recentData = allData.slice(-50);
            
            realtimeChart.data.labels = recentData.map(d => {
                const time = new Date(d.timestamp);
                return time.toLocaleTimeString();
            });
            realtimeChart.data.datasets[0].data = recentData.map(d => d.distance_cm);
            realtimeChart.update('none');
        }

        // Actualizar histograma
        function updateHistogram() {
            if (allData.length === 0) return;

            const distances = allData.map(d => d.distance_cm);
            const min = Math.min(...distances);
            const max = Math.max(...distances);
            const range = max - min;
            const binCount = 10;
            const binSize = range / binCount;

            const bins = [];
            const labels = [];

            for (let i = 0; i < binCount; i++) {
                const binStart = min + (i * binSize);
                const binEnd = binStart + binSize;
                const count = distances.filter(d => d >= binStart && d < binEnd).length;
                bins.push(count);
                labels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}`);
            }

            histogramChart.data.labels = labels;
            histogramChart.data.datasets[0].data = bins;
            histogramChart.update('none');
        }

        // Actualizar gráfica de tendencia
        function updateTrendChart() {
            if (allData.length === 0) return;

            const recentData = allData.slice(-20);
            
            trendChart.data.labels = recentData.map((_, index) => `#${index + 1}`);
            trendChart.data.datasets[0].data = recentData.map(d => d.distance_cm);
            trendChart.update('none');
        }

        // Actualizar última actualización
        function updateLastUpdate() {
            const now = new Date();
            lastUpdate.textContent = now.toLocaleTimeString();
        }

        // Obtener información del servidor con fallback IPv4/IPv6
        async function getServerInfo() {
            const port = 8000;
            const urls = [
                `http://[::1]:${port}/`,  // IPv6 localhost
                `http://localhost:${port}/`, // IPv4 localhost
                `http://127.0.0.1:${port}/`  // IPv4 explícito
            ];
            
            for (let i = 0; i < urls.length; i++) {
                try {
                    console.log(`Intentando conectar a: ${urls[i]}`);
                    const res = await fetch(urls[i], { cache: 'no-store' });
                    if (!res.ok) continue;
                    
                    const data = await res.json();
                    
                    // Mostrar la dirección IPv6 si está disponible
                    if (data.ipv6_address) {
                        ipv6Address.textContent = data.ipv6_address;
                    } else {
                        ipv6Address.textContent = `Conectado via ${i === 0 ? 'IPv6' : 'IPv4'}`;
                    }
                    
                    console.log(`Conectado exitosamente a: ${urls[i]}`);
                    return data;
                } catch (error) {
                    console.log(`Error con ${urls[i]}:`, error.message);
                    if (i === urls.length - 1) {
                        console.error('Error obteniendo info del servidor:', error);
                        ipv6Address.textContent = 'Error de conexión';
                        throw error;
                    }
                }
            }
        }

        // Precargar datos iniciales con fallback
        async function preloadData() {
            const port = 8000;
            const urls = [
                `http://[::1]:${port}/data?limit=200`,
                `http://localhost:${port}/data?limit=200`,
                `http://127.0.0.1:${port}/data?limit=200`
            ];
            
            for (let url of urls) {
                try {
                    console.log(`Intentando precargar datos desde: ${url}`);
                    const res = await fetch(url);
                    const initial = await res.json();
                    if (Array.isArray(initial)) {
                        for (const r of initial) addReading(r);
                        hasPreloaded = true;
                        updateStats();
                        updateRealtimeChart();
                        updateHistogram();
                        updateTrendChart();
                        console.log(`Datos precargados exitosamente desde: ${url}`);
                        return;
                    }
                } catch (e) {
                    console.warn(`No se pudo precargar datos desde ${url}:`, e);
                }
            }
        }

        // Conectar WebSocket con fallback
        async function connectWebSocket() {
            try {
                const serverInfo = await getServerInfo();
                await preloadData();

                // Intentar diferentes URLs de WebSocket
                const wsUrls = [
                    serverInfo.websocket_url, // URL del servidor
                    'ws://[::1]:8000/ws',    // IPv6 localhost
                    'ws://localhost:8000/ws', // IPv4 localhost
                    'ws://127.0.0.1:8000/ws' // IPv4 explícito
                ];
                
                connectionText.textContent = 'Conectando…';
                
                for (let wsUrl of wsUrls) {
                    try {
                        console.log(`Intentando WebSocket: ${wsUrl}`);
                        ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    isConnected = true;
                    statusIndicator.className = 'status-indicator status-connected';
                    connectionText.textContent = 'Conectado';
                    console.log(`WebSocket conectado exitosamente a: ${wsUrl}`);
                    return; // Salir del bucle si se conecta exitosamente
                };

                ws.onclose = function() {
                    isConnected = false;
                    statusIndicator.className = 'status-indicator status-disconnected';
                    connectionText.textContent = 'Desconectado — reconectando…';
                    
                    // Reintentar conexión después de 3 segundos
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onmessage = function(ev) {
                    const data = JSON.parse(ev.data);
                    const added = addReading(data);
                    if (!added) return; // ignorar duplicados
                    
                    updateStats();
                    updateRealtimeChart();
                    updateHistogram();
                    updateTrendChart();
                    updateLastUpdate();
                };

                ws.onerror = function() {
                    console.log(`Error en WebSocket: ${wsUrl}`);
                    // No hacer nada aquí, el onclose se encargará
                };
                
                // Esperar un poco antes de intentar la siguiente URL
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                         } catch (wsError) {
                 console.log(`Error creando WebSocket para ${wsUrl}:`, wsError);
                 if (wsUrls.indexOf(wsUrl) === wsUrls.length - 1) {
                     // Si es la última URL, mostrar error
                     statusIndicator.className = 'status-indicator status-disconnected';
                     connectionText.textContent = 'Error de conexión';
                     setTimeout(connectWebSocket, 3000);
                 }
             }
        }
        } catch (error) {
            statusIndicator.className = 'status-indicator status-disconnected';
            connectionText.textContent = 'Backend no disponible — reintentando…';
            setTimeout(connectWebSocket, 3000);
        }
        }

        // Inicializar dashboard
        function initDashboard() {
            initRealtimeChart();
            initHistogramChart();
            initTrendChart();
            connectWebSocket();
        }

        // Iniciar cuando se carga la página
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html> 